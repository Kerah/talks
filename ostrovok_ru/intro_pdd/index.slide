Чистый тест: применение на практике в go-разработке
11 nov 2024

Boris Bobejko
boris.bobeiko@tantorlabs.ru

* О болтуне

- Software Engineer (2006 - *)
- Lead Architect (2019-2023)
- Программированье-любопытный (1994 - *)
- Философ "Социального дна" (2016 - *)
- Test-automation-freak - (2013 - *)
- Создал ММОРПГ без единого теста (2009 - *)
- Создал финтех CDC без единого теста (2006- *)
- Создал решение для своего бизнеса без единого теста и познал суть "ошибки выжившего" (2010-2012)

* Цитаты великих: Роберт Мартин

- Если для кода не написаны тесты - он не может быть чистым.
- Если у вас есть тесты - вы не боитесь вносить изменения!
- Какой бы ни была ваша архитектура, без тестов вы будете сопротивляться изменениям из опасения, что они приведут к появлению скрытых ошибок.

.image ./books/clean-code.jpg _ 100
.image ./books/clean-code.gif _ 100


* Цитаты спикеров и авторов: Джонсон, Деоган, Савано

- Большинство программистов согласны с тем, что тестирование должно быть неотъемлемой частью процесса разработки.
- Такие методологии, как TDD и BDD, сделали фактическим стандартом подход, в котором при интеграции каждого изменения запускаются тысячи тестов.

.image ./books/sec-by-design.jpg _ 100
.image ./books/sec-by-design.gif

* Цитаты  спикеров и авторов: Крис Ричардсон

- Ручное тестирование чрезвычайно неэффективно.
- Никогда не просите человека сделать то, что у компьютера получится намного лучше.
- Если вы полагаетесь на ручное тестирование, забудьте о безопасной и доступной доставке программного обеспечения.


* Цитаты  спикеров и авторов: Владимир Хориков

- За 2 последних десятилетия индустрия начала постепенно практиковать юнит-тестирование.
- Во многих компаниях эти практики считаются обязательными.
- Многие программисты пишут юнит-тесты и понимают их важность.
- Разногласий относительно того, нужно ли заниматься юнит-тестированием, уже нет.

* Цитаты  спикеров и авторов: Александр Винокуров

- Представьте гипотетическую ситуацию: вы приходите в новый проект, и там нет тестов.
.image ./books/practical-testing-m-ostrovok.gif

* Отчёт Sauce Labs: Testing Trends

- Автоматизированными являются лишь 26% организаций.
- Полностью автоматизированными - жалкие 3%.

.image ./books/survey.gif _ 100

* О чём речь

- Рассказ о go и том, в чём всё таки проблема писать на нём хороший и надежный код
- О чем говорит метрика "code coverage"
- Как перестать использовать клиентов для отладки багов

* Сразу в дело

- Работаем с postgresql, используя драйвер pgx.
- Отделили систему хранения от остального кода, используя шаблон "репозиторий".
- Используем squirrel для декларативного описания SQL.
- В сообществе pgx'a узнали о крутой библиотеке хелперов - pgxutil.

.image ./dia/app_arch.png _ 1000

* Покажите код!

.code adt.go / StartRepoCountV1 OMIT/,/ EndRepoCountV1 OMIT/

* Проектируем архитектуру теста

- Тест использует настоящий постгрес в контейнере с миграцией схемы.
- Тесты можно запускать параллельно в полной изоляции друг от друга.
- Для верификации сетевых ошибок (или ошибок интеграции) - можно использовать мок

.image ./dia/test_arch.png _ 1000


* Напишем тест, который проверит код

.code adt_test.go / StartRepoCountV1Empty OMIT/,/ EndRepoCountV1Empty OMIT/


* Code Coverage: Golden Path (77.8%)

.image ./covs/countV1.png 350 _

* План рефакторинга

- Создадим функцию-декоратор для SelectBuilder'a.
- Уменьшим число блоков с ошибкой в бизнес-логике на 1.
- CC будет 88.9%, а на ошибку "базы" можно будет и не обращать внимания.

.image ./dia/refactoring_plan.png _ 1000

* Wrap/Decorate It!

.code ./pkg/resql/resql.go / StartSelectRow OMIT/,/ EndSelectRow OMIT/

- получили код, который можно протестировать на "моках"
- который проверим на пограничные кейсы

* Протестируем успешный кейс: Given

.code ./pkg/resql/resql_test.go / StartSuccess OMIT/,/ EndSuccess OMIT/

- Рандомизируем ожидаемое значение, так проще выявить проблему при возврате значений.
- Для теста нам нужен mock базы и возвращаемого значения rows.
- Rows это итератор, у котрого будут вызываться методы Next и Scan, используем для них - atomic'и.


* Протестируем успешный кейс: When

.code ./pkg/resql/resql_test.go / StartSuccessExpects OMIT/,/ EndSuccessExpects OMIT/

* Протестируем успешный кейс: Then

.code ./pkg/resql/resql_test.go / StartSuccessThen OMIT/,/ EndSuccessThen OMIT/

- Убедимся, что исполнение не приведёт к ошибке.
- Убедимся, что вернётся именно ожидаемое значение.

* Протестируем обработку неправильного SQL Builder'a

.code ./pkg/resql/resql_test.go / StartSqlInvalid OMIT/,/ EndSqlInvalid OMIT/

- Если squirrel получается SelectBuilder без "столбцов", он возвращает ошибку.
- Опишем вид такой ошибки контрактной ошибкой - ErrInvalidSql.
- Верифицируем, ошибку после исполнения функции.
- Обязательно проверим, что возвращаемое значение "пустое".

* Протестируем обработку ошибки в базе данных

.code ./pkg/resql/resql_test.go / StartDBFailV1 OMIT/,/ EndDBFailV2 OMIT/

- При вызове метода Query - возвратим ошибку.
- Сопоставим её с ожидаемой.
- ????
- Profit!

* Ожидание: resql 100% cc

.image ./covs/resql_cov.png 350 _

* Реальность

.image ./covs/resql_panic.png _ 900

* Что вообще пошло не так?

.image ./covs/panic_first.png _ 900

- Паника возникает при попытке закрыть интерфейс pgx.Rows.
- Но ведь мы вернули ошибку перед тем как вернуть этот интерфейс?

* А вот и десерт

.image ./covs/panic_reason.png _ 900



* WTF?

.code ./pkg/resql/resql.go / StartIF OMIT/,/ EndIF OMIT/

- Функция не обрабатывает ошибку, возникающую в методе Query, т.к. она скрывается в инстансе итератора.
- Потому что так реализована библиотека pgx.
- Потому что pgxutil писал автор библиотеки, который знал, что драйвер так реализован.

* GO Way: Simple better then clever

- Эта фраза содержит в себе двойное дно.
- Но тупой, в подавляющем количестве случаев, не лучше умного.

* Interfaces: the HELL for simples (ад для простаков)

- Интерфейс и мы, и автор библиотеки используют для снижения связанности кода.
- Интерфейс позволяет провести тестирование кода несложным (not complex) усилием.
- Интерфейс это абстрактный тип данных который может быть реализован различным образом.
- Сигнатура, содержащая (pgx.Rows, error), в традициях go, при возникновении ошибки вернет ошибку вторым аргументом и nil - первым.
- Если человек, не знакомый с реализацией pgx'a, начнёт реализовывать абстрактный тип данных, его приложение упадёт с паникой.

* Interfaces: Implementations ideas

- TxManager - мы можем реализовать фасад над pgx.Pool, который будет из контекста доставать транзакцию, которую туда поместят выше по стеку.
- Resharder - мы можем реализовать фасад, над шардированной базой данных, который на основании данных контекста (или анализа SQL запроса), будет определять, в какой из шардов отправится
- Metrics - мы можем спрятать за этим интерфейсом сбор метрик, спанов и прочий "мусор", важный для продакшена и его отладки.
- RWSplitter - мы можем использовать разные соединения к базам данных (реплику для чтения, мастер для записи).
- Cache - использовать много-уровневое кеширование, скрывая его от пользователя.
- Event Publishing - передавать сообщения в очереди при записи значений.

* Выводы

- То, что вы не знаете о багах в вашем софте, не значит, что их нет.
- Code coverage - позволяет проверить и найти проблемы простым и визуальным способом.
- Code coverage - позволяет декомпозировать код и изолировать проблемы, описывая контракты - тестами.
- Особенности - можно задокументировать на будущее, написав тест, ловящий панику.
- Контрактные тесты - можно создать пакет, который будет принимать на вход  вашу имплементацию и проверять, что она соблюдает контракты "поломанных библиотек"
- Жуки часто прячутся именно в непокрытых строках кода и в блоках обработки ошибок.

* Go way: все ошибки обработаны (кроме ошибок в генном коде)

- Огромное количество production кода не правильно и некорректно обрабатывает исключительные ситуации.
- Код на go выглядит так же, как код на python/kotlin/java - мозг игнорирует блоки обработки ошибок.
- Однако, в самих этих блоках ошибки и прячутся, выползая из них на production, тратя миллионы у компаний.

* Ошибка ценой в банковскую лицензию

.code samples_go /StartAcceptTransaction OMIT/,/EndAcceptTransaction OMIT/

* В каждой компании

.code samples_go /StartRegularHTTP OMIT/,/EndRegularHTTP OMIT/

- JSON маршаллер никогда не вернет ошибку!
- Ну конечно можно было бы лог написать, если в контекст записать не удалось данные

* Тем временем доменный примитив

.code samples_go /StartDomainPrimitive OMIT/,/EndDomainPrimitive OMIT/

- В финтехе здорово бы помог, если бы проверялся в среднем тесте.
- А ещё можно было бы не потерять деньги на списании, зачислив пользователям.
- Если бы использовался вашими коллегами, отправляющими вам транзакции из их микросервисов
- Это не добралось бы до прода, напиши они тесты на handler-слой

* Доменные примитивы

- Возвращают ошибки в Marshall
- Возвращают ошибки в Unmarshall
- При скане значений из базы.
- При отправке значений в базу (pg.jsonb, enums).
- Отличный способ реализовать энумераторы.
- Скрыть ошибку на сериалиайзере - выстрел себе в ногу, ценной в миллионы.

* Что демонстрирует мне Code coverage?

- Отношение разработчика к результату своего труда.
- Отношение менеджера к компании, которая его наняла.
- Инженерную культуру в компании
- Возможность принести пользу компании

* Teams/Company Grades

- 142% - мой код. Будет работать, и в итоге доступность от 99.95 до 99.99.
- 100% - мой код, когда нужно быстро вытащить на прод. Быстро создается, почти без побочных эффектов.
- 75% - аналог успешного пути. Не защищает от проблем и ошибок, но гарантирует работу функционала при изменениях. Обычно бывший java разработчик
- 50% - очень любящий го банк. Просто нужно, чтобы SRE за ним следили - нас заставили. Лояльны к технической некомпетентности, по их же словам.
- 25% - настоящий дикий и очень сочный финтех. Главное - темп выкладки, а не теряемые на авариях сотни миллионов.
- 0% - любая команда на go. У нас же есть QA, зачем нам самим писать тесты?

